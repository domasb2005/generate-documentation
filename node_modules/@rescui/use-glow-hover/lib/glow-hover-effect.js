import { linearAnimation } from './linear-animation.js';
import presets from './presets.js';
import { resetForcedTheme, forceLightTheme, forceDarkTheme } from './theme-utils.js';
const BURST_TIME = 300;

function parseColor(colorToParse) {
  const div = document.createElement('div');
  div.style.color = colorToParse;
  div.style.position = 'absolute';
  div.style.display = 'none';
  document.body.appendChild(div);
  const colorFromEl = getComputedStyle(div).color;
  document.body.removeChild(div);
  const parsedColor = colorFromEl.match(/^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)$/i);

  if (parsedColor) {
    const alpha = typeof parsedColor[4] === 'undefined' ? 1 : parsedColor[4];
    return [parsedColor[1], parsedColor[2], parsedColor[3], alpha];
  } else {
    console.error(`Color ${colorToParse} could not be parsed.`);
    return [0, 0, 0, 0];
  }
} // eslint-disable-next-line complexity


const glowHoverEffect = (el, _ref) => {
  let {
    preset,
    ...options
  } = _ref;

  if (!el) {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    return () => {};
  }

  let presetCfg = {};

  if (preset) {
    const maybePreset = presets[preset];

    if (!maybePreset) {
      throw new Error(`Unknown preset ${preset}`);
    }

    presetCfg = maybePreset;
  }

  const hoverBg = options.hoverBg ?? presetCfg.hoverBg;
  const lightColor = options.lightColor ?? presetCfg.lightColor;
  const lightSize = options.lightSize ?? presetCfg.lightSize ?? 100;
  const lightSizeEnterAnimationTime = options.lightSizeEnterAnimationTime ?? presetCfg.lightSizeEnterAnimationTime ?? 100;
  const lightSizeLeaveAnimationTime = options.lightSizeLeaveAnimationTime ?? presetCfg.lightSizeLeaveAnimationTime ?? 50;
  const isElementMovable = options.isElementMovable ?? presetCfg.isElementMovable ?? false;
  const customStaticBg = options.customStaticBg ?? presetCfg.customStaticBg ?? null;
  const mode = options.mode ?? presetCfg.mode ?? 'glow';
  let forceTheme = options.forceTheme ?? presetCfg.forceTheme ?? null; // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
  // @ts-ignore

  if (options.forceTypographyColors) {
    console.error('`forceTypographyColors` is deprecated for `useGlowHover`. Use `forceTheme` param instead.');

    if (forceTheme === null) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore
      forceTheme = options.forceTypographyColors;
    }
  }

  const enableBurst = options.enableBurst ?? presetCfg.enableBurst ?? false;

  const getResolvedHoverBg = () => hoverBg ?? getComputedStyle(el).backgroundColor;

  let resolvedHoverBg = getResolvedHoverBg(); // default bg (if not defined) is rgba(0, 0, 0, 0) which is bugged in gradients on safari
  // so we use transparent lightColor instead

  const parsedLightColor = parseColor(lightColor);
  const parsedLightColorRGBString = parsedLightColor.slice(0, 3).join(',');
  const resolvedGradientBg = `rgba(${parsedLightColorRGBString},0)`;
  let isMouseInside = false;
  let currentLightSize = 0;
  let blownSize = 0;
  let lightSizeEnterAnimationId = null;
  let lightSizeLeaveAnimationId = null;
  let blownSizeIncreaseAnimationId = null;
  let blownSizeDecreaseAnimationId = null;
  let lastMousePos;
  const defaultBox = el.getBoundingClientRect();
  let lastElPos = {
    x: defaultBox.left,
    y: defaultBox.top
  };

  const updateGlowEffect = () => {
    if (!lastMousePos) {
      return;
    }

    const gradientXPos = lastMousePos.x - lastElPos.x;
    const gradientYPos = lastMousePos.y - lastElPos.y;
    const circleRadius = `calc(${blownSize * 2.5}% + ${currentLightSize}px)`; // we dont use transparent color here because of https://youtrack.jetbrains.com/issue/WUI-843

    const smoothGradient = `radial-gradient(circle at ${gradientXPos}px ${gradientYPos}px, ${lightColor} 0%, ${resolvedGradientBg} ${circleRadius}) no-repeat`; // we dont use transparent color here because of https://youtrack.jetbrains.com/issue/WUI-843

    const sharpGradient = `radial-gradient(circle at ${gradientXPos}px ${gradientYPos}px, ${lightColor} ${circleRadius}, ${resolvedGradientBg} ${circleRadius}) no-repeat`;
    const gradient = mode === 'sharp' ? sharpGradient : smoothGradient; // we duplicate resolvedHoverBg layer here because of transition "blinking" without it (for example, Button component)

    el.style.background = `${gradient} border-box border-box ${resolvedHoverBg}`;
  };

  const updateEffectWithPosition = () => {
    if (isMouseInside) {
      const curBox = el.getBoundingClientRect();
      lastElPos = {
        x: curBox.left,
        y: curBox.top
      };
      updateGlowEffect();
    }
  };

  const onMouseEnter = e => {
    resolvedHoverBg = getResolvedHoverBg();
    lastMousePos = {
      x: e.clientX,
      y: e.clientY
    };
    const curBox = el.getBoundingClientRect();
    lastElPos = {
      x: curBox.left,
      y: curBox.top
    };
    isMouseInside = true;
    window.cancelAnimationFrame(lightSizeEnterAnimationId);
    window.cancelAnimationFrame(lightSizeLeaveAnimationId);

    if (forceTheme === 'light') {
      forceLightTheme(el);
    } else if (forceTheme === 'dark') {
      forceDarkTheme(el);
    } // animate currentLightSize from 0 to lightSize


    linearAnimation({
      onProgress: progress => {
        currentLightSize = lightSize * progress;
        updateGlowEffect();
      },
      time: lightSizeEnterAnimationTime,
      initialProgress: currentLightSize / lightSize,
      onIdUpdate: newId => lightSizeEnterAnimationId = newId
    });
  };

  const onMouseMove = e => {
    lastMousePos = {
      x: e.clientX,
      y: e.clientY
    };

    if (isElementMovable) {
      updateEffectWithPosition();
    } else {
      updateGlowEffect();
    }
  };

  const onMouseLeave = () => {
    isMouseInside = false;
    window.cancelAnimationFrame(lightSizeEnterAnimationId);
    window.cancelAnimationFrame(lightSizeLeaveAnimationId);
    window.cancelAnimationFrame(blownSizeIncreaseAnimationId);
    window.cancelAnimationFrame(blownSizeDecreaseAnimationId); // animate currentLightSize from lightSize to 0

    linearAnimation({
      onProgress: progress => {
        currentLightSize = lightSize * (1 - progress);
        blownSize = Math.min(blownSize, (1 - progress) * 100);

        if (progress < 1) {
          updateGlowEffect();
        } else {
          el.style.background = customStaticBg ? customStaticBg : '';
        }

        if (forceTheme && progress === 1) {
          resetForcedTheme(el);
        }
      },
      time: lightSizeLeaveAnimationTime,
      initialProgress: 1 - currentLightSize / lightSize,
      onIdUpdate: newId => lightSizeLeaveAnimationId = newId
    });
  };

  const onMouseDown = e => {
    lastMousePos = {
      x: e.clientX,
      y: e.clientY
    };
    const curBox = el.getBoundingClientRect();
    lastElPos = {
      x: curBox.left,
      y: curBox.top
    };
    window.cancelAnimationFrame(blownSizeIncreaseAnimationId);
    window.cancelAnimationFrame(blownSizeDecreaseAnimationId); // animate blownSize from 0 to 100

    linearAnimation({
      onProgress: progress => {
        blownSize = 100 * progress;
        updateGlowEffect();
      },
      time: BURST_TIME,
      initialProgress: blownSize / 100,
      onIdUpdate: newId => blownSizeIncreaseAnimationId = newId
    });
  };

  const onMouseUp = e => {
    lastMousePos = {
      x: e.clientX,
      y: e.clientY
    };
    const curBox = el.getBoundingClientRect();
    lastElPos = {
      x: curBox.left,
      y: curBox.top
    };
    window.cancelAnimationFrame(blownSizeIncreaseAnimationId);
    window.cancelAnimationFrame(blownSizeDecreaseAnimationId); // animate blownSize from 100 to 0

    linearAnimation({
      onProgress: progress => {
        blownSize = (1 - progress) * 100;
        updateGlowEffect();
      },
      time: BURST_TIME,
      initialProgress: 1 - blownSize / 100,
      onIdUpdate: newId => blownSizeDecreaseAnimationId = newId
    });
  };

  document.addEventListener('scroll', updateEffectWithPosition);
  window.addEventListener('resize', updateEffectWithPosition);
  el.addEventListener('mouseenter', onMouseEnter);
  el.addEventListener('mousemove', onMouseMove);
  el.addEventListener('mouseleave', onMouseLeave);

  if (enableBurst) {
    el.addEventListener('mousedown', onMouseDown);
    el.addEventListener('mouseup', onMouseUp);
  }

  let resizeObserver;

  if (window.ResizeObserver) {
    resizeObserver = new ResizeObserver(updateEffectWithPosition);
    resizeObserver.observe(el);
  }

  return () => {
    window.cancelAnimationFrame(lightSizeEnterAnimationId);
    window.cancelAnimationFrame(lightSizeLeaveAnimationId);
    window.cancelAnimationFrame(blownSizeIncreaseAnimationId);
    window.cancelAnimationFrame(blownSizeDecreaseAnimationId);
    document.removeEventListener('scroll', updateEffectWithPosition);
    window.removeEventListener('resize', updateEffectWithPosition);
    el.removeEventListener('mouseenter', onMouseEnter);
    el.removeEventListener('mousemove', onMouseMove);
    el.removeEventListener('mouseleave', onMouseLeave);

    if (enableBurst) {
      el.removeEventListener('mousedown', onMouseDown);
      el.removeEventListener('mouseup', onMouseUp);
    }

    if (forceTheme) {
      resetForcedTheme(el);
    }

    if (resizeObserver) {
      resizeObserver.unobserve(el);
      resizeObserver.disconnect();
    }
  };
};

export { glowHoverEffect, parseColor };
